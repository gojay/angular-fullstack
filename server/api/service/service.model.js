'use strict';

var mongoose = require('bluebird').promisifyAll(require('mongoose'));
var Schema = mongoose.Schema;
var tree = require('mongoose-path-tree');
var _ = require('lodash');
var Q = require('q');

var ServiceSchema = new Schema({
  name: String,
  price: { type: Number, default: 0 },
  picture: String,
  description: String,
  mode: { 
    type: Number,
    enum: [0, 1, 2], 
    default: 0
  },
  reference: Schema.Types.ObjectId,
  isRoot: { type: Boolean, default: false }
});

ServiceSchema.statics = {
  getAll() {
    return this.find({ isRoot: true }).exec().then((roots) => {
      if(_.isEmpty(roots)) return [];
      var promises = roots.map((root) => {
        return root.getChildrenAsync().then((result) => {
          var obj = root.toObject();
          obj.children = result;
          return obj;
        });
      });
      return Q.all(promises);
    });
  },

  getPrimary(parent = 'Services') {
    return this.findOne({ name: parent, isRoot: true }).select('_id').exec()
      .then((root) => {
        if(!root) return [];
        return this.find({ parent: root._id }).select('name price mode').exec();
      });
  },

	getChildren(reference) {
    var filters = { isRoot: true };
    if(_.isEmpty(reference)) {
      filters.name = 'Services';
    } else {
      filters._id = mongoose.Types.ObjectId(reference);
    }

    return this.findOne(filters).exec().then((root) => {
      if(!root) return [];
      return root.getChildrenAsync();
    });
  },

	getEstimatePrice(params) {
    if(_.isEmpty(params) || !params.ids) {
      throw new Error('Can\'t estimated price!! fields ids is required!');
    }

    var ids = params.ids.map((id) => { return mongoose.Types.ObjectId(id); });
		return this.find({ _id: { $in: ids } }).exec()
      .then((services) => {
      	if(_.isEmpty(services)) return { items: [], estimate_price: 0 };
        var promises = services.map((service) => {
        	return Q.Promise((resolve, reject) => {
  	        service.getAncestors({ isRoot: false }, 'name price', (err, result) => {
  	        	if(err) return reject(err);
  	          result.push(_.pick(service, ['name', 'price']));
  	          resolve({ items: result, estimate_price: _.sum(result, 'price') });
  	        });
        	});
        });
        return Q.all(promises).then((result) => {
          console.log('result', JSON.stringify(result, null, 2));
          return { items: [], estimate_price: 0 };
        });
      });
	},

  add(data) {
    if(!data.parent) return this.create(data);
    return this.findById(data.parent).exec().then((parent) => {
      if(!parent) throw new Error('Parent not found');
      var newService = _.pick(data, ['name', 'price'])
      var service = new this(newService);
      service.parent = parent;
      return service.savePromise();
    });
  }
};

ServiceSchema.methods = {
	savePromise() {
    return Q.Promise((resolve, reject) => {
    	this.save((err, result) => {
      	if(err) return reject(err);
      	resolve(result);
    	});
    });
	},

  getChildrenAsync(_params_ = {}) {
    var params = _.merge({ fields: '_id name price isRoot mode description reference' }, _params_);
    return Q.Promise((resolve, reject) => {
      this.getChildrenTree(params, (err, result) => {
        if(err) {
          reject(err)
        } else {
          resolve(result);
        }
      });
    })
  }
};

ServiceSchema.plugin(tree, {
  pathSeparator : '#',              // Default path separator
  onDelete :      'REPARENT',       // Can be set to 'DELETE' or 'REPARENT'. Default: 'REPARENT'
  // numWorkers:     5,           			// Number of stream workers
  idType:         Schema.ObjectId  	// Type used for _id. Can be, for example, String generated by shortid module
});

module.exports = mongoose.model('Service', ServiceSchema);
