'use strict';

var mongoose = require('bluebird').promisifyAll(require('mongoose'));
var Schema = mongoose.Schema;
var tree = require('mongoose-path-tree');
var _ = require('lodash');
var Q = require('q');

var ServiceSchema = new Schema({
  name: String,
  price: { type: Number, default: 0 },
  picture: String,
  description: String,
  mode: { 
    type: Number,
    enum: [0, 1, 2], 
    default: 0
  },
  reference: Schema.Types.ObjectId,
  isRoot: { type: Boolean, default: false }
});

ServiceSchema.statics = {
  getAll() {
    return this.find({ isRoot: true }).sort({ _id: 1 }).exec().then((roots) => {
      if(_.isEmpty(roots)) return [];
      var q = Q.defer();
      var data = [];
      var promises = _.reduce(roots, (promise, root) => {
        return promise.then(() => {
          return Q.Promise((resolve, reject) => {
            root.getChildrenTree({ fields: '_id name price isRoot mode reference' }, (err, result) => {
              if(err) {
                reject(err)
              } else {
                var obj = root.toObject();
                obj.children = result;
                resolve(obj);
              }
            });
          }).then((result) => {
            data.push(result);
            return data;
          });
        });
      }, q.promise);
      q.resolve();
      return promises;
    });
    // return this.findOne({ isRoot: true }).exec().then((root) => {
    //   if(!root) return [];
    //   return Q.Promise((resolve, reject) => {
    //     root.getChildrenTree({ fields: '_id name price isRoot mode' }, (err, result) => {
    //       if(err) {
    //         reject(err)
    //       } else {
    //         var obj = root.toObject();
    //         obj.children = result;
    //         resolve([obj]);
    //       }
    //     });
    //   })
    // });
  },

  getPrimary(parent = 'Services') {
    return this.findOne({ name: parent, isRoot: true }).select('_id').exec()
      .then((root) => {
        if(!root) return [];
        return this.find({ parent: root._id }).select('name price mode').exec();
      });
  },

	getChildren(reference) {
    var filters = { isRoot: true };
    if(_.isEmpty(reference)) {
      filters.name = 'Services';
    } else {
      filters._id = mongoose.Types.ObjectId(reference);
    }

		return this.findOne(filters).exec().then((root) => {
			if(!root) return [];
			return Q.Promise((resolve, reject) => {
      	root.getChildrenTree({ fields: 'name mode reference' }, (err, result) => {
      		if(err) {
      			reject(err)
      		} else {
      			resolve(result);
      		}
      	});
			})
    });
	},

	getEstimatePrice(params) {
    if(_.isEmpty(params) || !params.ids) {
      throw new Error('Can\'t estimated price!! fields ids is required!');
    }

    var ids = _.map(ids, (id) => { return mongoose.Types.ObjectId(id); });
		return this.find({ _id: { $in: ids } }).exec()
      .then((services) => {
      	if(_.isEmpty(services)) return { id: service._id, lists: [], estimate_price: 0 };
        var promises = _.map(services, (service) => {
          console.log('service', service)
        	return Q.Promise((resolve, reject) => {
  	        service.getAncestors({ isRoot: false }, 'name price', (err, result) => {
  	        	if(err) return reject(err);
  	          result.push(_.pick(service, ['name', 'price']));
  	          resolve({ id: service._id, lists: result, estimate_price: _.sum(result, 'price') });
  	        });
        	});
        });
        return promises;
      });
	},

  add(data) {
    return this.findById(data.parent).exec().then((parent) => {
      if(!parent) throw new Error('Parent not found');
      var newService = _.pick(data, ['name', 'price'])
      var service = new this(newService);
      service.parent = parent;
      return service.savePromise();
    });
  }
};

ServiceSchema.methods = {
	savePromise() {
    return Q.Promise((resolve, reject) => {
    	this.save((err, result) => {
      	if(err) return reject(err);
      	resolve(result);
    	});
    });
	}
};

ServiceSchema.plugin(tree, {
  pathSeparator : '#',              // Default path separator
  onDelete :      'REPARENT',       // Can be set to 'DELETE' or 'REPARENT'. Default: 'REPARENT'
  // numWorkers:     5,           			// Number of stream workers
  idType:         Schema.ObjectId  	// Type used for _id. Can be, for example, String generated by shortid module
});

module.exports = mongoose.model('Service', ServiceSchema);
